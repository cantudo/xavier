import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../../store/store';
// import { fetchCount } from './counterApi';
import { VoltageWaveform, PulseControls, StdpControls, StdpWaveform } from './types'
import { pulseMeasurement, getMeasurement, stdpMeasurement } from './api'
import { Measurement } from '../../../utils/types';
import { fetchMeasurements } from '../../../store/globalSlice';
import math from '../../../utils/math'

export interface WaveformState {
  waveform: {
    // scaling: {}
    points: VoltageWaveform | StdpWaveform
  },
  measurement: null | Measurement,
  pulseParams: PulseControls,
  stdpParams: StdpControls,
  avgTime: string,
  timeScale: number,
  previewWaveform: boolean
}

const initialState: WaveformState = {
  waveform: {
    points: []
  },
  measurement: null,
  pulseParams: {
    vHigh: "1 V",
    vLow: "0 V",
    nPulses: "10",
    cycleTime: "10 us",
    dutyCycle: "50",
    nPointsHigh: "10",
    nPointsLow: "10"
  },
  stdpParams: {
    delay: "500 ns",
    amplitude: "300 V",
    pulseDuration: "2 us",
    waitTime: "1 us"  ,
    nPoints: "1000"  
  },
  avgTime: "10 ns",
  timeScale: 1, // scale to apply on the x axis,
  previewWaveform: false // wether waveform preview is activated or not
};

export const waveformSlice = createSlice({
  name: 'waveform',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // increment: (state) => {
    //   // Redux Toolkit allows us to write "mutating" logic in reducers. It
    //   // doesn't actually mutate the state because it uses the Immer library,
    //   // which detects changes to a "draft state" and produces a brand new
    //   // immutable state based off those changes
    //   state.value += 1;
    // },
    // Use the PayloadAction type to declare the contents of `action.payload`
    setPoints: (state, action: PayloadAction< VoltageWaveform | StdpWaveform >) => {
      state.waveform.points = action.payload;
    },
    setPulseParamsField: (state, action: PayloadAction<{ val: string, key: keyof PulseControls }>) => {

      if (action.payload.key == 'nPointsHigh' || action.payload.key == 'nPointsLow') {
        let totalPoints = parseInt(action.payload.val as string);
        if (action.payload.key == 'nPointsHigh')
          totalPoints = totalPoints + parseInt(state.pulseParams.nPointsLow)
        if (action.payload.key == 'nPointsLow')
          totalPoints = totalPoints + parseInt(state.pulseParams.nPointsHigh)
        if (math.unit(state.pulseParams.cycleTime).value / totalPoints < 10e-8) {

          let actualPoints = parseInt(state.pulseParams.nPointsHigh) + parseInt(state.pulseParams.nPointsLow)

          let maxP = Math.floor(math.unit(state.pulseParams.cycleTime).value / 10e-8)
          if (actualPoints != maxP) {
            state.pulseParams = {
              ...state.pulseParams,
              nPointsHigh: Math.floor(maxP / 2).toString(),
              nPointsLow: Math.floor(maxP / 2).toString()
            }
          }


          return
        }
      }

      state.pulseParams = {
        ...state.pulseParams,
        [action.payload.key]: action.payload.val
      }
    },

    setStdpParamsField: (state, action: PayloadAction<{val: string, key: keyof StdpControls}>) => {
      state.stdpParams = {
        ...state.stdpParams,
        [action.payload.key]: action.payload.val
      }
    },
    setAvgTime(state, action: PayloadAction<string>) {
      state.avgTime = action.payload
    },
    setMeasurement: (state, action: PayloadAction< Measurement >) => {
      state.measurement = action.payload;
    },
    emptyMeasurement: (state) => {
      state.measurement = null;
    },
    setTimeScale: (state, action: PayloadAction<number>) => {
      state.timeScale = action.payload
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: (builder) => {
  //   builder
  //     .addCase(incrementAsync.pending, (state) => {
  //       state.status = 'loading';
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = 'idle';
  //       state.value += action.payload;
  //     })
  //     .addCase(incrementAsync.rejected, (state) => {
  //       state.status = 'failed';
  //     });
  // },
});

export const { setPoints, setPulseParamsField, setStdpParamsField, setAvgTime, setMeasurement, emptyMeasurement, setTimeScale } = waveformSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectWaveform = (state: RootState) => state.waveform.waveform.points;
export const selectPulseParams = (state: RootState) => state.waveform.pulseParams;
export const selectStdpParams = (state: RootState) => state.waveform.stdpParams;
export const selectAvgTime = (state: RootState) => state.waveform.avgTime;
export const selectMeasurement = (state: RootState) => state.waveform.measurement;
export const selectTimeScale = (state: RootState) => state.waveform.timeScale;

export const fetchMeasurement = createAsyncThunk<void, number, { state: RootState }>(
  'wgfmu/get-measurement',
  async (id: number, thunkAPI) => {
    const response = (await getMeasurement(id)) as Measurement
    let data = response.data ?? []
    if (response.status != "InProgress") {
      let measurement = {
        ...response,
        data: data.length > 10000 ? data.slice(0, 10000) : data
      } as Measurement
      thunkAPI.dispatch(setMeasurement(measurement))
    }
  }
)

export const waitForMeasurement = createAsyncThunk<void, number, { state: RootState }>(
  'wgfmu/wait-measurement',
  async (id: number, thunkAPI) => {
    setTimeout(async () => {
      try {
        await thunkAPI.dispatch(fetchMeasurement(id))
        let state = thunkAPI.getState()
        if (state.waveform.measurement && state.waveform.measurement.id == id && (state.waveform.measurement.status == "Done" || state.waveform.measurement.status == "Error")) {
          thunkAPI.dispatch(fetchMeasurements())
        } else {
          thunkAPI.dispatch(waitForMeasurement(id))
        }
      } catch { }
    }, 500)
  }
)

export const measurePulse = createAsyncThunk<void, void, { state: RootState }>(
  'wgfmu/measure-pulse',
  async (arg: void, thunkAPI) => {


    const pulseParams = selectPulseParams(thunkAPI.getState())
    const avgTime = selectAvgTime(thunkAPI.getState())

    const response = await pulseMeasurement(pulseParams, avgTime);


    const id = response.id;

    if (id == undefined) {
      return
    }

    thunkAPI.dispatch(emptyMeasurement())

    thunkAPI.dispatch(waitForMeasurement(id))

    console.log(response)
  }
)

export const measureStdp = createAsyncThunk<void, void, { state: RootState }>(
  'wgfmu/measure-pulse',
  async (arg: void, thunkAPI) => {


    const params = selectStdpParams(thunkAPI.getState())
    const avgTime = selectAvgTime(thunkAPI.getState())

    const response = await stdpMeasurement(params, avgTime);

    const id = response.id;

    if (id == undefined) {
      return
    }

    thunkAPI.dispatch(emptyMeasurement())

    thunkAPI.dispatch(waitForMeasurement(id))

    console.log(response)
  }
)


export default waveformSlice.reducer;
